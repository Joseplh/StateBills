<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BoxSite: node-mssql</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BoxSite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__c___users__joseph_workspace__state_bills__box_site_frontend_node_modules_mssql__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">node-mssql </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Microsoft SQL Server client for Node.js</p>
<p><a href="https://www.npmjs.com/package/mssql"><img src="https://img.shields.io/npm/v/mssql.svg?style=flat-square" alt="NPM Version" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/mssql"><img src="https://img.shields.io/npm/dm/mssql.svg?style=flat-square" alt="NPM Downloads" style="pointer-events: none;" class="inline"/></a> <a href="https://travis-ci.org/tediousjs/node-mssql"><img src="https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&amp;label=unit" alt="Travis CI" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/tediousjs/node-mssql"><img src="https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true" alt="Appveyor CI" class="inline"/></a> <a href="https://gitter.im/patriksimek/node-mssql?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/patriksimek/node-mssql" style="pointer-events: none;" class="inline"/></a></p>
<p>Supported TDS drivers:</p><ul>
<li><a href="https://www.npmjs.com/package/tedious">Tedious</a> (pure JavaScript - Windows/macOS/Linux, default)</li>
<li><a href="https://www.npmjs.com/package/msnodesqlv8">Microsoft / Contributors Node V8 Driver for Node.js for SQL Server</a> (native - Windows only)</li>
</ul>
<h1><a class="anchor" id="autotoc_md14839"></a>
Installation</h1>
<pre class="fragment">npm install mssql
</pre><h1><a class="anchor" id="autotoc_md14840"></a>
Quick Example</h1>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">async () =&gt; {</div>
<div class="line">    try {</div>
<div class="line">        // make sure that any items are correctly URL encoded in the connection string</div>
<div class="line">        await sql.connect(&#39;mssql://username:password@localhost/database&#39;)</div>
<div class="line">        const result = await sql.query`select * from mytable where id = ${value}`</div>
<div class="line">        console.dir(result)</div>
<div class="line">    } catch (err) {</div>
<div class="line">        // ... error checks</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you're on Windows Azure, add <code>?encrypt=true</code> to your connection string. See <a href="#configuration">docs</a> to learn more.</p>
<p>Parts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.</p>
<h1><a class="anchor" id="autotoc_md14841"></a>
Documentation</h1>
<h2><a class="anchor" id="autotoc_md14842"></a>
Examples</h2>
<ul>
<li><a href="#asyncawait">Async/Await</a></li>
<li><a href="#promises">Promises</a></li>
<li><a href="#es6-tagged-template-literals">ES6 Tagged template literals</a></li>
<li><a href="#callbacks">Callbacks</a></li>
<li><a href="#streaming">Streaming</a></li>
<li><a href="#connection-pools">Connection Pools</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14843"></a>
Configuration</h2>
<ul>
<li><a href="#general-same-for-all-drivers">General</a></li>
<li><a href="#formats">Formats</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14844"></a>
Drivers</h2>
<ul>
<li><a href="#tedious">Tedious</a></li>
<li><a href="#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server">Microsoft / Contributors Node V8 Driver for Node.js for SQL Server</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14845"></a>
Connections</h2>
<ul>
<li><a href="#pool-management">Pool Management</a></li>
<li><a href="#connections-1">ConnectionPool</a></li>
<li><a href="#connect-callback">connect</a></li>
<li><a href="#close">close</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14846"></a>
Requests</h2>
<ul>
<li><a href="#request">Request</a></li>
<li><a href="#execute-procedure-callback">execute</a></li>
<li><a href="#input-name-type-value">input</a></li>
<li><a href="#output-name-type-value">output</a></li>
<li><a href="#pipe-stream">pipe</a></li>
<li><a href="#query-command-callback">query</a></li>
<li><a href="#batch-batch-callback">batch</a></li>
<li><a href="#bulk-table-options-callback">bulk</a></li>
<li><a href="#cancel">cancel</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14847"></a>
Transactions</h2>
<ul>
<li><a href="#transaction">Transaction</a></li>
<li><a href="#begin-isolationlevel-callback">begin</a></li>
<li><a href="#commit-callback">commit</a></li>
<li><a href="#rollback-callback">rollback</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14848"></a>
Prepared Statements</h2>
<ul>
<li><a href="#prepared-statement">PreparedStatement</a></li>
<li><a href="#input-name-type">input</a></li>
<li><a href="#output-name-type">output</a></li>
<li><a href="#prepare-statement-callback">prepare</a></li>
<li><a href="#execute-values-callback">execute</a></li>
<li><a href="#unprepare-callback">unprepare</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14849"></a>
Other</h2>
<ul>
<li><a href="#cli">CLI</a></li>
<li><a href="#geography-and-geometry">Geography and Geometry</a></li>
<li><a href="#table-valued-parameter-tvp">Table-Valued Parameter</a></li>
<li><a href="#affected-rows">Affected Rows</a></li>
<li><a href="#json-support">JSON support</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#informational-messages">Informational messages</a></li>
<li><a href="#metadata">Metadata</a></li>
<li><a href="#data-types">Data Types</a></li>
<li><a href="#sql-injection">SQL injection</a></li>
<li><a href="#known-issues">Known Issues</a></li>
<li><a href="https://github.com/tediousjs/node-mssql/wiki/Contributing">Contributing</a></li>
<li><a href="#5x-to-6x-changes">5.x to 6.x changes</a></li>
<li><a href="#4x-to-5x-changes">4.x to 5.x changes</a></li>
<li><a href="#3x-to-4x-changes">3.x to 4.x changes</a></li>
<li><a href="https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md">3.x Documentation</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md14850"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md14851"></a>
Config</h2>
<div class="fragment"><div class="line">const config = {</div>
<div class="line">    user: &#39;...&#39;,</div>
<div class="line">    password: &#39;...&#39;,</div>
<div class="line">    server: &#39;localhost&#39;, // You can use &#39;localhost\\instance&#39; to connect to named instance</div>
<div class="line">    database: &#39;...&#39;,</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14852"></a>
Async/Await</h2>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">(async function () {</div>
<div class="line">    try {</div>
<div class="line">        let pool = await sql.connect(config)</div>
<div class="line">        let result1 = await pool.request()</div>
<div class="line">            .input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">            .query(&#39;select * from mytable where id = @input_parameter&#39;)</div>
<div class="line">            </div>
<div class="line">        console.dir(result1)</div>
<div class="line">    </div>
<div class="line">        // Stored procedure</div>
<div class="line">        </div>
<div class="line">        let result2 = await pool.request()</div>
<div class="line">            .input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">            .output(&#39;output_parameter&#39;, sql.VarChar(50))</div>
<div class="line">            .execute(&#39;procedure_name&#39;)</div>
<div class="line">        </div>
<div class="line">        console.dir(result2)</div>
<div class="line">    } catch (err) {</div>
<div class="line">        // ... error checks</div>
<div class="line">    }</div>
<div class="line">})()</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14853"></a>
Promises</h2>
<h3><a class="anchor" id="autotoc_md14854"></a>
Queries</h3>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">sql.connect(config).then(pool =&gt; {</div>
<div class="line">    // Query</div>
<div class="line">    </div>
<div class="line">    return pool.request()</div>
<div class="line">        .input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">        .query(&#39;select * from mytable where id = @input_parameter&#39;)</div>
<div class="line">}).then(result =&gt; {</div>
<div class="line">    console.dir(result)</div>
<div class="line">}).catch(err =&gt; {</div>
<div class="line">  // ... error checks</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14855"></a>
Stored procedures</h3>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">sql.connect(config).then(pool =&gt; {</div>
<div class="line">    </div>
<div class="line">    // Stored procedure</div>
<div class="line">    </div>
<div class="line">    return pool.request()</div>
<div class="line">        .input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">        .output(&#39;output_parameter&#39;, sql.VarChar(50))</div>
<div class="line">        .execute(&#39;procedure_name&#39;)</div>
<div class="line">}).then(result =&gt; {</div>
<div class="line">    console.dir(result)</div>
<div class="line">}).catch(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p>Native Promise is used by default. You can easily change this with &lsquo;sql.Promise = require('myownpromisepackage&rsquo;)`.</p>
<h2><a class="anchor" id="autotoc_md14856"></a>
ES6 Tagged template literals</h2>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">sql.connect(config).then(() =&gt; {</div>
<div class="line">    return sql.query`select * from mytable where id = ${value}`</div>
<div class="line">}).then(result =&gt; {</div>
<div class="line">    console.dir(result)</div>
<div class="line">}).catch(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
</div><!-- fragment --><p>All values are automatically sanitized against sql injection. This is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply. e.g. Column names cannot be passed/set in statements using variables.</p>
<h2><a class="anchor" id="autotoc_md14857"></a>
Callbacks</h2>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">sql.connect(config, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    // Query</div>
<div class="line"> </div>
<div class="line">    new sql.Request().query(&#39;select 1 as number&#39;, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">        console.dir(result)</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    // Stored Procedure</div>
<div class="line"> </div>
<div class="line">    new sql.Request()</div>
<div class="line">    .input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">    .output(&#39;output_parameter&#39;, sql.VarChar(50))</div>
<div class="line">    .execute(&#39;procedure_name&#39;, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">        console.dir(result)</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    // Using template literal</div>
<div class="line"> </div>
<div class="line">    const request = new sql.Request()</div>
<div class="line">    request.query(request.template`select * from mytable where id = ${value}`, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line">        console.dir(result)</div>
<div class="line">    })</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14858"></a>
Streaming</h2>
<p>If you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.</p>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">sql.connect(config, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    const request = new sql.Request()</div>
<div class="line">    request.stream = true // You can set streaming differently for each request</div>
<div class="line">    request.query(&#39;select * from verylargetable&#39;) // or request.execute(procedure)</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;recordset&#39;, columns =&gt; {</div>
<div class="line">        // Emitted once for each recordset in a query</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;row&#39;, row =&gt; {</div>
<div class="line">        // Emitted for each row in a recordset</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">        // May be emitted multiple times</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;done&#39;, result =&gt; {</div>
<div class="line">        // Always emitted as the last one</div>
<div class="line">    })</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">sql.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
</div><!-- fragment --><p>When streaming large sets of data you want to back-off or chunk the amount of data you're processing to prevent memory exhaustion issues; you can use the <code>Request.pause()</code> function to do this. Here is an example of managing rows in batches of 15:</p>
<div class="fragment"><div class="line">let rowsToProcess = [];</div>
<div class="line">request.on(&#39;row&#39;, row =&gt; {</div>
<div class="line">  rowsToProcess.push(row);</div>
<div class="line">  if (rowsToProcess.length &gt;= 15) {</div>
<div class="line">    request.pause();</div>
<div class="line">    processRows();</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line">request.on(&#39;done&#39;, () =&gt; {</div>
<div class="line">    processRows();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">function processRows() {</div>
<div class="line">  // process rows</div>
<div class="line">  rowsToProcess = [];</div>
<div class="line">  request.resume();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14859"></a>
Pool Management</h1>
<p>An important concept to understand when using this library is <a href="https://en.wikipedia.org/wiki/Connection_pool">Connection Pooling</a> as this library uses connection pooling extensively.</p>
<p>As one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process to create a pool of database connections for reuse; this saves overhead of connecting to the database for each request (as would be the case in something like PHP, where one process handles one request).</p>
<p>With the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand how the pooling is working, it is simple to make use of it efficiently and effectively.</p>
<h2><a class="anchor" id="autotoc_md14860"></a>
The Global Connection (Pool)</h2>
<p>To assist with pool management in your application there is the global <code>connect()</code> function that is available for use. As of v6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you do not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected, it will resolve to the connected pool. For example:</p>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">// run a query against the global connection pool</div>
<div class="line">function runQuery(query) {</div>
<div class="line">  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn&#39;t</div>
<div class="line">  return sql.connect().then((pool) =&gt; {</div>
<div class="line">    return pool.query(query)</div>
<div class="line">  })</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we obtain the global connection pool by running <code>sql.connect()</code> and we then run the query against the pool. We also do <em>not</em> close the pool after the query is executed and that is because other queries may need to be run against this pool and closing it will add an overhead to running the query. We should only ever close the pool when our application is finished. For example, if we are running some kind of CLI tool or a CRON job:</p>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">(() =&gt; {</div>
<div class="line">  sql.connect().then(pool =&gt; {</div>
<div class="line">    return pool.query(&#39;SELECT 1&#39;)</div>
<div class="line">  }).then(result =&gt; {</div>
<div class="line">    // do something with result</div>
<div class="line">  }).then(() =&gt; {</div>
<div class="line">    return sql.close()</div>
<div class="line">  })</div>
<div class="line">})()</div>
</div><!-- fragment --><p>Here the connection will be closed and the node process will exit once the queries and other application logic has completed. You should aim to only close the pool once in your application, when it is exiting or you know your application will never make another SQL query.</p>
<h2><a class="anchor" id="autotoc_md14861"></a>
Advanced Pool Management</h2>
<p>In some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have one pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool management.</p>
<p>That could look something like this:</p>
<div class="fragment"><div class="line">const { ConnectionPool } = require(&#39;mssql&#39;)</div>
<div class="line">const POOLS = {}</div>
<div class="line"> </div>
<div class="line">function createPool(config, name) {</div>
<div class="line">  if (getPool(name)) {</div>
<div class="line">    throw new Error(&#39;Pool with this name already exists&#39;)</div>
<div class="line">  }</div>
<div class="line">  return POOLS[name] = (new ConnectionPool(config)).connect()</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function closePool(name) {</div>
<div class="line">  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {</div>
<div class="line">    const pool = POOLS[name];</div>
<div class="line">    delete POOLS[name];</div>
<div class="line">    return pool.close()</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function getPool(name) {</div>
<div class="line">  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {</div>
<div class="line">    return POOLS[name]</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module.exports = {</div>
<div class="line">  closePool,</div>
<div class="line">  createPool,</div>
<div class="line">  getPool</div>
<div class="line">}</div>
</div><!-- fragment --><p>This helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you should aim to only close a pool when you know it will never be needed by the application again; typically this will be when your application is shutting down.</p>
<h1><a class="anchor" id="autotoc_md14862"></a>
Connection Pools</h1>
<p>Using a single connection pool for your application/service is recommended. Instantiating a pool with a callback, or immediately calling <code>.connect</code>, is asynchronous to ensure a connection can be established before returning. From that point, you're able to acquire connections as normal: <br  />
</p>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">// async/await style:</div>
<div class="line">const pool1 = new sql.ConnectionPool(config);</div>
<div class="line">const pool1Connect = pool1.connect();</div>
<div class="line"> </div>
<div class="line">pool1.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">async function messageHandler() {</div>
<div class="line">    await pool1Connect; // ensures that the pool has been created</div>
<div class="line">    try {</div>
<div class="line">        const request = pool1.request(); // or: new sql.Request(pool1)</div>
<div class="line">        const result = await request.query(&#39;select 1 as number&#39;)</div>
<div class="line">        console.dir(result)</div>
<div class="line">        return result;</div>
<div class="line">    } catch (err) {</div>
<div class="line">        console.error(&#39;SQL error&#39;, err);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// promise style:</div>
<div class="line">const pool2 = new sql.ConnectionPool(config)</div>
<div class="line">const pool2Connect = pool2.connect()</div>
<div class="line"> </div>
<div class="line">pool2.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ... error handler</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">function runStoredProcedure() {</div>
<div class="line">    return pool2Connect.then((pool) =&gt; {</div>
<div class="line">        pool.request() // or: new sql.Request(pool2)</div>
<div class="line">        .input(&#39;input_parameter&#39;, sql.Int, 10)</div>
<div class="line">        .output(&#39;output_parameter&#39;, sql.VarChar(50))</div>
<div class="line">        .execute(&#39;procedure_name&#39;, (err, result) =&gt; {</div>
<div class="line">            // ... error checks</div>
<div class="line">            console.dir(result)</div>
<div class="line">        })</div>
<div class="line">    }).catch(err =&gt; {</div>
<div class="line">        // ... error handler</div>
<div class="line">    })</div>
<div class="line">}</div>
</div><!-- fragment --><p>Awaiting or <code>.then</code>ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it is needed first. In practice, once the pool is created then there will be no delay for the next operation.</p>
<p>As of v6.1.0 you can make repeat calls to <code>ConnectionPool.connect()</code> and <code>ConnectonPool.close()</code> without an error being thrown, allowing for the safe use of <code>mssql.connect().then(...)</code> throughout your code as well as making multiple calls to close when your application is shutting down.</p>
<p>The ability to call <code>connect()</code> repeatedly is intended to make pool management easier, however it is still recommended to follow the example above where <code>connect()</code> is called once and using the original resolved connection promise. Repeatedly calling <code>connect()</code> when running queries risks running into problems when <code>close()</code> is called on the pool.</p>
<p><b>ES6 Tagged template literals</b></p>
<div class="fragment"><div class="line">new sql.ConnectionPool(config).connect().then(pool =&gt; {</div>
<div class="line">    return pool.query`select * from mytable where id = ${value}`</div>
<div class="line">}).then(result =&gt; {</div>
<div class="line">    console.dir(result)</div>
<div class="line">}).catch(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p>All values are automatically sanitized against sql injection.</p>
<h2><a class="anchor" id="autotoc_md14863"></a>
Managing connection pools</h2>
<p>Most applications will only need a single <code>ConnectionPool</code> that can be shared throughout the code. To aid the sharing of a single pool this library exposes a set of functions to access a single global connection. eg:</p>
<div class="fragment"><div class="line">// as part of your application&#39;s boot process</div>
<div class="line"> </div>
<div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line">const poolPromise = sql.connect()</div>
<div class="line"> </div>
<div class="line">// during your applications runtime</div>
<div class="line"> </div>
<div class="line">poolPromise.then(() =&gt; {</div>
<div class="line">  return sql.query(&#39;SELECT 1&#39;)</div>
<div class="line">}).then(result =&gt; {</div>
<div class="line">  console.dir(result)</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// when your application exits</div>
<div class="line">poolPromise.then(() =&gt; {</div>
<div class="line">  return sql.close()</div>
<div class="line">})</div>
</div><!-- fragment --><p>If you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only pool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that can hold references to the pools for you. For example:</p>
<div class="fragment"><div class="line">const sql = require(&#39;mssql&#39;)</div>
<div class="line"> </div>
<div class="line">const pools = {}</div>
<div class="line"> </div>
<div class="line">// manage a set of pools by name (config will be required to create the pool)</div>
<div class="line">// a pool will be removed when it is closed</div>
<div class="line">async function getPool(name, config) {</div>
<div class="line">  if (!Object.prototype.hasOwnProperty.call(pools, name)) {</div>
<div class="line">    const pool = new sql.ConnectionPool(config)</div>
<div class="line">    const close = pool.close.bind(pool)</div>
<div class="line">    pool.close = (...args) =&gt; {</div>
<div class="line">      delete pools[name]</div>
<div class="line">      return close(...args)</div>
<div class="line">    }</div>
<div class="line">    await pool.connect()</div>
<div class="line">    pools[name] = pool</div>
<div class="line">  }</div>
<div class="line">  return pools[name]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// close all pools</div>
<div class="line">function closeAll() {</div>
<div class="line">  return Promise.all(Object.values(pools).map((pool) =&gt; {</div>
<div class="line">    return pool.close()</div>
<div class="line">  }))</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module.exports = {</div>
<div class="line">  closeAll,</div>
<div class="line">  getPool</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can then use this library file in your code to get a connected pool when you need it:</p>
<div class="fragment"><div class="line">const { getPool } = require(&#39;./path/to/file&#39;)</div>
<div class="line"> </div>
<div class="line">// run a query</div>
<div class="line">async function runQuery(query, config) {</div>
<div class="line">  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid</div>
<div class="line">  const pool = await getPool(&#39;default&#39;, config)</div>
<div class="line">  const result = await pool.request().query(query)</div>
<div class="line">  return result</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14864"></a>
Configuration</h1>
<div class="fragment"><div class="line">const config = {</div>
<div class="line">    user: &#39;...&#39;,</div>
<div class="line">    password: &#39;...&#39;,</div>
<div class="line">    server: &#39;localhost&#39;,</div>
<div class="line">    database: &#39;...&#39;,</div>
<div class="line">    pool: {</div>
<div class="line">        max: 10,</div>
<div class="line">        min: 0,</div>
<div class="line">        idleTimeoutMillis: 30000</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14865"></a>
General (same for all drivers)</h2>
<ul>
<li><b>user</b> - User name to use for authentication.</li>
<li><b>password</b> - Password to use for authentication.</li>
<li><b>server</b> - Server to connect to. You can use 'localhost\instance' to connect to named instance.</li>
<li><b>port</b> - Port to connect to (default: <code>1433</code>). Don't set when connecting to named instance.</li>
<li><b>domain</b> - Once you set domain, driver will connect to SQL Server using domain login.</li>
<li><b>database</b> - Database to connect to (default: dependent on server configuration).</li>
<li><b>connectionTimeout</b> - Connection timeout in ms (default: <code>15000</code>).</li>
<li><b>requestTimeout</b> - Request timeout in ms (default: <code>15000</code>). NOTE: msnodesqlv8 driver doesn't support timeouts &lt; 1 second. When passed via connection string, the key must be <code>request timeout</code></li>
<li><b>stream</b> - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: <code>false</code>). You can also enable streaming for each request independently (<code>request.stream = true</code>). Always set to <code>true</code> if you plan to work with large amount of rows.</li>
<li><b>parseJSON</b> - Parse JSON recordsets to JS objects (default: <code>false</code>). For more information please see section <a href="#json-support">JSON support</a>.</li>
<li><b>pool.max</b> - The maximum number of connections there can be in the pool (default: <code>10</code>).</li>
<li><b>pool.min</b> - The minimum of connections there can be in the pool (default: <code>0</code>).</li>
<li><b>pool.idleTimeoutMillis</b> - The Number of milliseconds before closing an unused connection (default: <code>30000</code>).</li>
</ul>
<p>Complete list of pool options can be found <a href="https://github.com/vincit/tarn.js/#usage">here</a>.</p>
<h2><a class="anchor" id="autotoc_md14866"></a>
Formats</h2>
<p>In addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.</p>
<h4><a class="anchor" id="autotoc_md14867"></a>
Classic Connection String</h4>
<div class="fragment"><div class="line">Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true</div>
<div class="line">Driver=msnodesqlv8;Server=(local)\INSTANCE;Database=database;UID=DOMAIN\username;PWD=password;Encrypt=true</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md14868"></a>
Connection String URI</h4>
<div class="fragment"><div class="line">mssql://username:password@localhost:1433/database?encrypt=true</div>
<div class="line">mssql://username:password@localhost/INSTANCE/database?encrypt=true&amp;domain=DOMAIN&amp;driver=msnodesqlv8</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14869"></a>
Drivers</h1>
<h2><a class="anchor" id="autotoc_md14870"></a>
Tedious</h2>
<p>Default driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.</p>
<p><b>Extra options:</b></p>
<ul>
<li><b>beforeConnect(conn)</b> - Function, which is invoked before opening the connection. The parameter <code>conn</code> is the configured tedious <code>Connection</code>. It can be used for attaching event handlers like in this example: <div class="fragment"><div class="line">require(&#39;mssql&#39;).connect(...config, beforeConnect: conn =&gt; {</div>
<div class="line">  conn.once(&#39;connect&#39;, err =&gt; { err ? console.error(err) : console.log(&#39;mssql connected&#39;)})</div>
<div class="line">  conn.once(&#39;end&#39;, err =&gt; { err ? console.error(err) : console.log(&#39;mssql disconnected&#39;)})</div>
<div class="line">}})</div>
</div><!-- fragment --></li>
<li><b>options.instanceName</b> - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.</li>
<li><b>options.useUTC</b> - A boolean determining whether or not use UTC time for values without time zone offset (default: <code>true</code>).</li>
<li><b>options.encrypt</b> - A boolean determining whether or not the connection will be encrypted (default: <code>true</code>).</li>
<li><b>options.tdsVersion</b> - The version of TDS to use (default: <code>7_4</code>, available: <code>7_1</code>, <code>7_2</code>, <code>7_3_A</code>, <code>7_3_B</code>, <code>7_4</code>).</li>
<li><b>options.appName</b> - Application name used for SQL server logging.</li>
<li><b>options.abortTransactionOnError</b> - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for <code>XACT_ABORT</code> during the initial SQL phase of a connection.</li>
</ul>
<p>More information about Tedious specific options: <a href="http://tediousjs.github.io/tedious/api-connection.html">http://tediousjs.github.io/tedious/api-connection.html</a></p>
<h2><a class="anchor" id="autotoc_md14871"></a>
Microsoft / Contributors Node V8 Driver for Node.js for SQL Server</h2>
<p><b>Requires Node.js 0.12.x or newer. Windows only.</b> This driver is not part of the default package and must be installed separately by <code>npm install msnodesqlv8</code>. To use this driver, use this require syntax: &lsquo;const sql = require('mssql/msnodesqlv8&rsquo;)`.</p>
<p><b>Extra options:</b></p>
<ul>
<li><b>beforeConnect(conn)</b> - Function, which is invoked before opening the connection. The parameter <code>conn</code> is the connection configuration, that can be modified to pass extra parameters to the driver's <code>open()</code> method.</li>
<li><b>connectionString</b> - Connection string (default: see below).</li>
<li><b>options.instanceName</b> - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.</li>
<li><b>options.trustedConnection</b> - Use Windows Authentication (default: <code>false</code>).</li>
<li><b>options.useUTC</b> - A boolean determining whether or not to use UTC time for values without time zone offset (default: <code>true</code>).</li>
</ul>
<p>Default connection string when connecting to port: </p><div class="fragment"><div class="line">Driver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};</div>
</div><!-- fragment --><p>Default connection string when connecting to named instance: </p><div class="fragment"><div class="line">Driver={SQL Server Native Client 11.0};Server={#{server}\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14872"></a>
Connections</h1>
<p>Internally, each <code>ConnectionPool</code> instance is a separate pool of TDS connections. Once you create a new <code>Request</code>/<code>Transaction</code>/<code>Prepared Statement</code>, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.</p>
<p><b>IMPORTANT</b>: Always attach an <code>error</code> listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.</p>
<div class="fragment"><div class="line">const pool = new sql.ConnectionPool({ /* config */ })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14873"></a>
Events</h2>
<ul>
<li><b>error(err)</b> - Dispatched on connection error.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14875"></a>
connect ([callback])</h2>
<p>Create a new connection pool. The initial probe connection is created to find out whether the configuration is valid.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>callback(err)</b> - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const pool = new sql.ConnectionPool({</div>
<div class="line">    user: &#39;...&#39;,</div>
<div class="line">    password: &#39;...&#39;,</div>
<div class="line">    server: &#39;localhost&#39;,</div>
<div class="line">    database: &#39;...&#39;</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">pool.connect(err =&gt; {</div>
<div class="line">    // ...</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ELOGIN (<code>ConnectionError</code>) - Login failed.</li>
<li>ETIMEOUT (<code>ConnectionError</code>) - Connection timeout.</li>
<li>EALREADYCONNECTED (<code>ConnectionError</code>) - Database is already connected!</li>
<li>EALREADYCONNECTING (<code>ConnectionError</code>) - Already connecting to database!</li>
<li>EINSTLOOKUP (<code>ConnectionError</code>) - Instance lookup failed.</li>
<li>ESOCKET (<code>ConnectionError</code>) - Socket error.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14877"></a>
close()</h2>
<p>Close all active connections in the pool.</p>
<p><b>Example</b></p>
<div class="fragment"><div class="line">pool.close()</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14878"></a>
Request</h1>
<div class="fragment"><div class="line">const request = new sql.Request(/* [pool or transaction] */)</div>
</div><!-- fragment --><p>If you omit pool/transaction argument, global pool is used instead.</p>
<h2><a class="anchor" id="autotoc_md14879"></a>
Events</h2>
<ul>
<li><b>recordset(columns)</b> - Dispatched when metadata for new recordset are parsed.</li>
<li><b>row(row)</b> - Dispatched when new row is parsed.</li>
<li><b>done(returnValue)</b> - Dispatched when request is complete.</li>
<li><b>error(err)</b> - Dispatched on error.</li>
<li><b>info(message)</b> - Dispatched on informational message.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14881"></a>
execute (procedure, [callback])</h2>
<p>Call a stored procedure.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>procedure</b> - Name of the stored procedure to be executed.</li>
<li><b>callback(err, recordsets, returnValue)</b> - A callback which is called after execution has completed, or an error has occurred. <code>returnValue</code> is also accessible as property of recordsets. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.input(&#39;input_parameter&#39;, sql.Int, value)</div>
<div class="line">request.output(&#39;output_parameter&#39;, sql.Int)</div>
<div class="line">request.execute(&#39;procedure_name&#39;, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    console.log(result.recordsets.length) // count of recordsets returned by the procedure</div>
<div class="line">    console.log(result.recordsets[0].length) // count of rows contained in first recordset</div>
<div class="line">    console.log(result.recordset) // first recordset from result.recordsets</div>
<div class="line">    console.log(result.returnValue) // procedure return value</div>
<div class="line">    console.log(result.output) // key/value collection of output values</div>
<div class="line">    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens</div>
<div class="line"> </div>
<div class="line">    // ...</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>EREQUEST (<code>RequestError</code>) - <em>Message from SQL Server</em></li>
<li>ECANCEL (<code>RequestError</code>) - Cancelled.</li>
<li>ETIMEOUT (<code>RequestError</code>) - Request timeout.</li>
<li>ENOCONN (<code>RequestError</code>) - No connection is specified for that request.</li>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>ECONNCLOSED (<code>ConnectionError</code>) - Connection is closed.</li>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EABORT (<code>TransactionError</code>) - Transaction was aborted (by user or because of an error).</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14883"></a>
input (name, [type], value)</h2>
<p>Add an input parameter to the request.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>name</b> - Name of the input parameter without &amp;nbsp;char.</li>
<li><b>type</b> - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.</li>
<li><b>value</b> - Input parameter value. <code>undefined</code> ans <code>NaN</code> values are automatically converted to <code>null</code> values.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">request.input(&#39;input_parameter&#39;, value)</div>
<div class="line">request.input(&#39;input_parameter&#39;, sql.Int, value)</div>
</div><!-- fragment --><p><b>JS Data Type To SQL Data Type Map</b></p>
<ul>
<li><code>String</code> -&gt;&#160;<code>sql.NVarChar</code></li>
<li><code>Number</code> -&gt; <code>sql.Int</code></li>
<li><code>Boolean</code> -&gt; <code>sql.Bit</code></li>
<li><code>Date</code> -&gt; <code>sql.DateTime</code></li>
<li><code>Buffer</code> -&gt; <code>sql.VarBinary</code></li>
<li><code>sql.Table</code> -&gt; <code>sql.TVP</code></li>
</ul>
<p>Default data type for unknown object is <code>sql.NVarChar</code>.</p>
<p>You can define your own type map.</p>
<div class="fragment"><div class="line">sql.map.register(MyClass, sql.Text)</div>
</div><!-- fragment --><p>You can also overwrite the default type map.</p>
<div class="fragment"><div class="line">sql.map.register(Number, sql.BigInt)</div>
</div><!-- fragment --><p><b>Errors</b> (synchronous)</p><ul>
<li>EARGS (<code>RequestError</code>) - Invalid number of arguments.</li>
<li>EINJECT (<code>RequestError</code>) - SQL injection warning.</li>
</ul>
<hr  />
<p>NB: Do not use parameters <code>@p{n}</code> as these are used by the internal drivers and cause a conflict.</p>
<h2><a class="anchor" id="autotoc_md14885"></a>
output (name, type, [value])</h2>
<p>Add an output parameter to the request.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>name</b> - Name of the output parameter without &amp;nbsp;char.</li>
<li><b>type</b> - SQL data type of output parameter.</li>
<li><b>value</b> - Output parameter value initial value. <code>undefined</code> and <code>NaN</code> values are automatically converted to <code>null</code> values. Optional.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">request.output(&#39;output_parameter&#39;, sql.Int)</div>
<div class="line">request.output(&#39;output_parameter&#39;, sql.VarChar(50), &#39;abc&#39;)</div>
</div><!-- fragment --><p><b>Errors</b> (synchronous)</p><ul>
<li>EARGS (<code>RequestError</code>) - Invalid number of arguments.</li>
<li>EINJECT (<code>RequestError</code>) - SQL injection warning.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14887"></a>
pipe (stream)</h2>
<p>Sets request to <code>stream</code> mode and pulls all rows from all recordsets to a given stream.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>stream</b> - Writable stream in object mode.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.pipe(stream)</div>
<div class="line">request.query(&#39;select * from mytable&#39;)</div>
<div class="line">stream.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">    // ...</div>
<div class="line">})</div>
<div class="line">stream.on(&#39;finish&#39;, () =&gt; {</div>
<div class="line">    // ...</div>
<div class="line">})</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md14889"></a>
query (command, [callback])</h2>
<p>Execute the SQL command. To execute commands like <code>create procedure</code> or if you plan to work with local temporary tables, use <a href="#batch-batch-callback">batch</a> instead.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>command</b> - T-SQL command to be executed.</li>
<li><b>callback(err, recordset)</b> - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;select 1 as number&#39;, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    console.log(result.recordset[0].number) // return 1</div>
<div class="line"> </div>
<div class="line">    // ...</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ETIMEOUT (<code>RequestError</code>) - Request timeout.</li>
<li>EREQUEST (<code>RequestError</code>) - <em>Message from SQL Server</em></li>
<li>ECANCEL (<code>RequestError</code>) - Cancelled.</li>
<li>ENOCONN (<code>RequestError</code>) - No connection is specified for that request.</li>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>ECONNCLOSED (<code>ConnectionError</code>) - Connection is closed.</li>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EABORT (<code>TransactionError</code>) - Transaction was aborted (by user or because of an error).</li>
</ul>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;select 1 as number; select 2 as number&#39;, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    console.log(result.recordset[0].number) // return 1</div>
<div class="line">    console.log(result.recordsets[0][0].number) // return 1</div>
<div class="line">    console.log(result.recordsets[1][0].number) // return 2</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>NOTE</b>: To get number of rows affected by the statement(s), see section <a href="#affected-rows">Affected Rows</a>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md14891"></a>
batch (batch, [callback])</h2>
<p>Execute the SQL command. Unlike <a href="#query-command-callback">query</a>, it doesn't use <code>sp_executesql</code>, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like <code>create procedure</code> which can't be executed with <a href="#query-command-callback">query</a> or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables (<a href="http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx">more information here</a>).</p>
<p>NOTE: Table-Valued Parameter (TVP) is not supported in batch.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>batch</b> - T-SQL command to be executed.</li>
<li><b>callback(err, recordset)</b> - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.batch(&#39;create procedure #temporary as select * from table&#39;, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ETIMEOUT (<code>RequestError</code>) - Request timeout.</li>
<li>EREQUEST (<code>RequestError</code>) - <em>Message from SQL Server</em></li>
<li>ECANCEL (<code>RequestError</code>) - Cancelled.</li>
<li>ENOCONN (<code>RequestError</code>) - No connection is specified for that request.</li>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>ECONNCLOSED (<code>ConnectionError</code>) - Connection is closed.</li>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EABORT (<code>TransactionError</code>) - Transaction was aborted (by user or because of an error).</li>
</ul>
<p>You can enable multiple recordsets in queries with the <code>request.multiple = true</code> command.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md14893"></a>
bulk (table, [options,] [callback])</h2>
<p>Perform a bulk insert.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>table</b> - <code>sql.Table</code> instance.</li>
<li><b>options</b> - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.</li>
<li><b>callback(err, rowCount)</b> - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const table = new sql.Table(&#39;table_name&#39;) // or temporary table, e.g. #temptable</div>
<div class="line">table.create = true</div>
<div class="line">table.columns.add(&#39;a&#39;, sql.Int, {nullable: true, primary: true})</div>
<div class="line">table.columns.add(&#39;b&#39;, sql.VarChar(50), {nullable: false})</div>
<div class="line">table.rows.add(777, &#39;test&#39;)</div>
<div class="line"> </div>
<div class="line">const request = new sql.Request()</div>
<div class="line">request.bulk(table, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>IMPORTANT</b>: Always indicate whether the column is nullable or not!</p>
<p><b>TIP</b>: If you set <code>table.create</code> to <code>true</code>, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting <code>primary: true</code> to column's options. Primary key constraint on multiple columns is supported.</p>
<p><b>TIP</b>: You can also create Table variable from any recordset with <code>recordset.toTable()</code>. You can optionally specify table type name in the first argument.</p>
<p><b>Errors</b></p><ul>
<li>ENAME (<code>RequestError</code>) - Table name must be specified for bulk insert.</li>
<li>ETIMEOUT (<code>RequestError</code>) - Request timeout.</li>
<li>EREQUEST (<code>RequestError</code>) - <em>Message from SQL Server</em></li>
<li>ECANCEL (<code>RequestError</code>) - Cancelled.</li>
<li>ENOCONN (<code>RequestError</code>) - No connection is specified for that request.</li>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>ECONNCLOSED (<code>ConnectionError</code>) - Connection is closed.</li>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EABORT (<code>TransactionError</code>) - Transaction was aborted (by user or because of an error).</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14895"></a>
cancel()</h2>
<p>Cancel currently executing request. Return <code>true</code> if cancellation packet was send successfully.</p>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;waitfor delay \&#39;00:00:05\&#39;; select 1 as number&#39;, (err, result) =&gt; {</div>
<div class="line">    console.log(err instanceof sql.RequestError)  // true</div>
<div class="line">    console.log(err.message)                      // Cancelled.</div>
<div class="line">    console.log(err.code)                         // ECANCEL</div>
<div class="line"> </div>
<div class="line">    // ...</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">request.cancel()</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14896"></a>
Transaction</h1>
<p><b>IMPORTANT:</b> always use <code>Transaction</code> class to create transactions - it ensures that all your requests are executed on one connection. Once you call <code>begin</code>, a single connection is acquired from the connection pool and all subsequent requests (initialized with the <code>Transaction</code> object) are executed exclusively on this connection. After you call <code>commit</code> or <code>rollback</code>, connection is then released back to the connection pool.</p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction(/* [pool] */)</div>
</div><!-- fragment --><p>If you omit connection argument, global connection is used instead.</p>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction(/* [pool] */)</div>
<div class="line">transaction.begin(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    const request = new sql.Request(transaction)</div>
<div class="line">    request.query(&#39;insert into mytable (mycolumn) values (12345)&#39;, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">        transaction.commit(err =&gt; {</div>
<div class="line">            // ... error checks</div>
<div class="line"> </div>
<div class="line">            console.log(&quot;Transaction committed.&quot;)</div>
<div class="line">        })</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p>Transaction can also be created by <code>const transaction = pool.transaction()</code>. Requests can also be created by <code>const request = transaction.request()</code>.</p>
<p><b>Aborted transactions</b></p>
<p>This example shows how you should correctly handle transaction errors when <code>abortTransactionOnError</code> (<code>XACT_ABORT</code>) is enabled. Added in 2.0.</p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction(/* [pool] */)</div>
<div class="line">transaction.begin(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    let rolledBack = false</div>
<div class="line"> </div>
<div class="line">    transaction.on(&#39;rollback&#39;, aborted =&gt; {</div>
<div class="line">        // emited with aborted === true</div>
<div class="line"> </div>
<div class="line">        rolledBack = true</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    new sql.Request(transaction)</div>
<div class="line">    .query(&#39;insert into mytable (bitcolumn) values (2)&#39;, (err, result) =&gt; {</div>
<div class="line">        // insert should fail because of invalid value</div>
<div class="line"> </div>
<div class="line">        if (err) {</div>
<div class="line">            if (!rolledBack) {</div>
<div class="line">                transaction.rollback(err =&gt; {</div>
<div class="line">                    // ... error checks</div>
<div class="line">                })</div>
<div class="line">            }</div>
<div class="line">        } else {</div>
<div class="line">            transaction.commit(err =&gt; {</div>
<div class="line">                // ... error checks</div>
<div class="line">            })</div>
<div class="line">        }</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14897"></a>
Events</h2>
<ul>
<li><b>begin</b> - Dispatched when transaction begin.</li>
<li><b>commit</b> - Dispatched on successful commit.</li>
<li><b>rollback(aborted)</b> - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14899"></a>
begin ([isolationLevel], [callback])</h2>
<p>Begin a transaction.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>isolationLevel</b> - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. <code>READ_COMMITTED</code> by default. For possible values see <code>sql.ISOLATION_LEVEL</code>.</li>
<li><b>callback(err)</b> - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction()</div>
<div class="line">transaction.begin(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>EALREADYBEGUN (<code>TransactionError</code>) - Transaction has already begun.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14901"></a>
commit ([callback])</h2>
<p>Commit a transaction.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>callback(err)</b> - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction()</div>
<div class="line">transaction.begin(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    transaction.commit(err =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EREQINPROG (<code>TransactionError</code>) - Can't commit transaction. There is a request in progress.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14903"></a>
rollback ([callback])</h2>
<p>Rollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>callback(err)</b> - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const transaction = new sql.Transaction()</div>
<div class="line">transaction.begin(err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    transaction.rollback(err =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
<li>EREQINPROG (<code>TransactionError</code>) - Can't rollback transaction. There is a request in progress.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14904"></a>
Prepared Statement</h1>
<p><b>IMPORTANT:</b> always use <code>PreparedStatement</code> class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call <code>prepare</code>, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call <code>unprepare</code>, the connection is then released back to the connection pool.</p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement(/* [pool] */)</div>
</div><!-- fragment --><p>If you omit the connection argument, the global connection is used instead.</p>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement(/* [pool] */)</div>
<div class="line">ps.input(&#39;param&#39;, sql.Int)</div>
<div class="line">ps.prepare(&#39;select @param as value&#39;, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    ps.execute({param: 12345}, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">        // release the connection after queries are executed</div>
<div class="line">        ps.unprepare(err =&gt; {</div>
<div class="line">            // ... error checks</div>
<div class="line"> </div>
<div class="line">        })</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>IMPORTANT</b>: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!</p>
<p>You can execute multiple queries against the same prepared statement but you <em>must</em> unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.</p>
<p><b>TIP</b>: You can also create prepared statements in transactions (<code>new sql.PreparedStatement(transaction)</code>), but keep in mind you can't execute other requests in the transaction until you call <code>unprepare</code>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md14906"></a>
input (name, type)</h2>
<p>Add an input parameter to the prepared statement.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>name</b> - Name of the input parameter without &amp;nbsp;char.</li>
<li><b>type</b> - SQL data type of input parameter.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">ps.input(&#39;input_parameter&#39;, sql.Int)</div>
<div class="line">ps.input(&#39;input_parameter&#39;, sql.VarChar(50))</div>
</div><!-- fragment --><p><b>Errors</b> (synchronous)</p><ul>
<li>EARGS (<code>PreparedStatementError</code>) - Invalid number of arguments.</li>
<li>EINJECT (<code>PreparedStatementError</code>) - SQL injection warning.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14908"></a>
output (name, type)</h2>
<p>Add an output parameter to the prepared statement.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>name</b> - Name of the output parameter without &amp;nbsp;char.</li>
<li><b>type</b> - SQL data type of output parameter.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">ps.output(&#39;output_parameter&#39;, sql.Int)</div>
<div class="line">ps.output(&#39;output_parameter&#39;, sql.VarChar(50))</div>
</div><!-- fragment --><p><b>Errors</b> (synchronous)</p><ul>
<li>EARGS (<code>PreparedStatementError</code>) - Invalid number of arguments.</li>
<li>EINJECT (<code>PreparedStatementError</code>) - SQL injection warning.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14910"></a>
prepare (statement, [callback])</h2>
<p>Prepare a statement.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>statement</b> - T-SQL statement to prepare.</li>
<li><b>callback(err)</b> - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement()</div>
<div class="line">ps.prepare(&#39;select @param as value&#39;, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ENOTOPEN (<code>ConnectionError</code>) - Connection not yet open.</li>
<li>EALREADYPREPARED (<code>PreparedStatementError</code>) - Statement is already prepared.</li>
<li>ENOTBEGUN (<code>TransactionError</code>) - Transaction has not begun.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14912"></a>
execute (values, [callback])</h2>
<p>Execute a prepared statement.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>values</b> - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.</li>
<li><b>callback(err)</b> - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement()</div>
<div class="line">ps.input(&#39;param&#39;, sql.Int)</div>
<div class="line">ps.prepare(&#39;select @param as value&#39;, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    ps.execute({param: 12345}, (err, result) =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">        console.log(result.recordset[0].value) // return 12345</div>
<div class="line">        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.</div>
<div class="line">        </div>
<div class="line">        ps.unprepare(err =&gt; {</div>
<div class="line">            // ... error checks</div>
<div class="line">        })</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p>You can also stream executed request.</p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement()</div>
<div class="line">ps.input(&#39;param&#39;, sql.Int)</div>
<div class="line">ps.prepare(&#39;select @param as value&#39;, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    ps.stream = true</div>
<div class="line">    const request = ps.execute({param: 12345})</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;recordset&#39;, columns =&gt; {</div>
<div class="line">        // Emitted once for each recordset in a query</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;row&#39;, row =&gt; {</div>
<div class="line">        // Emitted for each row in a recordset</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;error&#39;, err =&gt; {</div>
<div class="line">        // May be emitted multiple times</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    request.on(&#39;done&#39;, result =&gt; {</div>
<div class="line">        // Always emitted as the last one</div>
<div class="line">        </div>
<div class="line">        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.</div>
<div class="line">        </div>
<div class="line">        ps.unprepare(err =&gt; {</div>
<div class="line">            // ... error checks</div>
<div class="line">        })</div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>TIP</b>: To learn more about how number of affected rows works, see section <a href="#affected-rows">Affected Rows</a>.</p>
<p><b>Errors</b></p><ul>
<li>ENOTPREPARED (<code>PreparedStatementError</code>) - Statement is not prepared.</li>
<li>ETIMEOUT (<code>RequestError</code>) - Request timeout.</li>
<li>EREQUEST (<code>RequestError</code>) - <em>Message from SQL Server</em></li>
<li>ECANCEL (<code>RequestError</code>) - Cancelled.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14914"></a>
unprepare ([callback])</h2>
<p>Unprepare a prepared statement.</p>
<p><b>Arguments</b></p>
<ul>
<li><b>callback(err)</b> - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns <a href="#promises">Promise</a>.</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">const ps = new sql.PreparedStatement()</div>
<div class="line">ps.input(&#39;param&#39;, sql.Int)</div>
<div class="line">ps.prepare(&#39;select @param as value&#39;, err =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    ps.unprepare(err =&gt; {</div>
<div class="line">        // ... error checks</div>
<div class="line"> </div>
<div class="line">    })</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Errors</b></p><ul>
<li>ENOTPREPARED (<code>PreparedStatementError</code>) - Statement is not prepared.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14915"></a>
CLI</h1>
<p>Before you can start using CLI, you must install <code>mssql</code> globally with <code>npm install mssql -g</code>. Once you do that you will be able to execute <code>mssql</code> command.</p>
<p><b>Setup</b></p>
<p>Create a <code>.mssql.json</code> configuration file (anywhere). Structure of the file is the same as the standard configuration object.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;user&quot;: &quot;...&quot;,</div>
<div class="line">    &quot;password&quot;: &quot;...&quot;,</div>
<div class="line">    &quot;server&quot;: &quot;localhost&quot;,</div>
<div class="line">    &quot;database&quot;: &quot;...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Example</b></p>
<div class="fragment"><div class="line">echo &quot;select * from mytable&quot; | mssql /path/to/config</div>
</div><!-- fragment --><p>Results in: </p><div class="fragment"><div class="line">[[{&quot;username&quot;:&quot;patriksimek&quot;,&quot;password&quot;:&quot;tooeasy&quot;}]]</div>
</div><!-- fragment --><p>You can also query for multiple recordsets.</p>
<div class="fragment"><div class="line">echo &quot;select * from mytable; select * from myothertable&quot; | mssql</div>
</div><!-- fragment --><p>Results in: </p><div class="fragment"><div class="line">[[{&quot;username&quot;:&quot;patriksimek&quot;,&quot;password&quot;:&quot;tooeasy&quot;}],[{&quot;id&quot;:15,&quot;name&quot;:&quot;Product name&quot;}]]</div>
</div><!-- fragment --><p>If you omit config path argument, mssql will try to load it from current working directory.</p>
<h1><a class="anchor" id="autotoc_md14916"></a>
Geography and Geometry</h1>
<p>node-mssql has built-in serializer for Geography and Geometry CLR data types.</p>
<div class="fragment"><div class="line"><span class="keyword">select</span> geography::STGeomFromText(<span class="stringliteral">&#39;LINESTRING(-122.360 47.656, -122.343 47.656 )&#39;</span>, <span class="stringliteral">4326</span>)</div>
<div class="line"><span class="keyword">select</span> geometry::STGeomFromText(<span class="stringliteral">&#39;LINESTRING (100 100 10.3 12, 20 180, 180 180)&#39;</span>, <span class="stringliteral">0</span>)</div>
</div><!-- fragment --><p>Results in:</p>
<div class="fragment"><div class="line">{ srid: 4326,</div>
<div class="line">  version: 1,</div>
<div class="line">  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],</div>
<div class="line">  figures: [ { attribute: 1, pointOffset: 0 } ],</div>
<div class="line">  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],</div>
<div class="line">  segments: [] }</div>
<div class="line"> </div>
<div class="line">{ srid: 0,</div>
<div class="line">  version: 1,</div>
<div class="line">  points:</div>
<div class="line">   [ { x: 100, y: 100, z: 10.3, m: 12 },</div>
<div class="line">     { x: 20, y: 180, z: NaN, m: NaN },</div>
<div class="line">     { x: 180, y: 180, z: NaN, m: NaN } ],</div>
<div class="line">  figures: [ { attribute: 1, pointOffset: 0 } ],</div>
<div class="line">  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],</div>
<div class="line">  segments: [] }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14917"></a>
Table-Valued Parameter (TVP)</h1>
<p>Supported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.</p>
<div class="fragment"><div class="line"><span class="keyword">CREATE</span> TYPE TestType <span class="keyword">AS</span> <span class="keyword">TABLE</span> ( a <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>), b <span class="keywordtype">INT</span> );</div>
</div><!-- fragment --><p>Next we will need a stored procedure.</p>
<div class="fragment"><div class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> MyCustomStoredProcedure (<span class="preprocessor">@tvp</span> TestType readonly) <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="preprocessor">@tvp</span></div>
</div><!-- fragment --><p>Now let's go back to our Node.js app.</p>
<div class="fragment"><div class="line">const tvp = new sql.Table() // You can optionally specify table type name in the first argument.</div>
<div class="line"> </div>
<div class="line">// Columns must correspond with type we have created in database.</div>
<div class="line">tvp.columns.add(&#39;a&#39;, sql.VarChar(50))</div>
<div class="line">tvp.columns.add(&#39;b&#39;, sql.Int)</div>
<div class="line"> </div>
<div class="line">// Add rows</div>
<div class="line">tvp.rows.add(&#39;hello tvp&#39;, 777) // Values are in same order as columns.</div>
</div><!-- fragment --><p>You can send table as a parameter to stored procedure.</p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.input(&#39;tvp&#39;, tvp)</div>
<div class="line">request.execute(&#39;MyCustomStoredProcedure&#39;, (err, result) =&gt; {</div>
<div class="line">    // ... error checks</div>
<div class="line"> </div>
<div class="line">    console.dir(result.recordsets[0][0]) // {a: &#39;hello tvp&#39;, b: 777}</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>TIP</b>: You can also create Table variable from any recordset with <code>recordset.toTable()</code>. You can optionally specify table type name in the first argument.</p>
<h1><a class="anchor" id="autotoc_md14918"></a>
Affected Rows</h1>
<p>If you're performing <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> in a query, you can read number of affected rows. The <code>rowsAffected</code> variable is an array of numbers. Each number represents number of affected rows by a single statement.</p>
<p><b>Example using Promises</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;update myAwesomeTable set awesomness = 100&#39;).then(result =&gt; {</div>
<div class="line">    console.log(result.rowsAffected)</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Example using callbacks</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;update myAwesomeTable set awesomness = 100&#39;, (err, result) =&gt; {</div>
<div class="line">    console.log(result.rowsAffected)</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>Example using streaming</b></p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.stream = true</div>
<div class="line">request.query(&#39;update myAwesomeTable set awesomness = 100&#39;)</div>
<div class="line">request.on(&#39;done&#39;, result =&gt; {</div>
<div class="line">    console.log(result.rowsAffected)</div>
<div class="line">})</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14919"></a>
JSON support</h1>
<p>SQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named <code>JSON_F52E2B61-18A1-11d1-B105-00805F49916B</code>.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keyword">SELECT</span></div>
<div class="line">    <span class="stringliteral">1</span> <span class="keyword">AS</span> <span class="stringliteral">&#39;a.b.c&#39;</span>,</div>
<div class="line">    <span class="stringliteral">2</span> <span class="keyword">AS</span> <span class="stringliteral">&#39;a.b.d&#39;</span>,</div>
<div class="line">    <span class="stringliteral">3</span> <span class="keyword">AS</span> <span class="stringliteral">&#39;a.x&#39;</span>,</div>
<div class="line">    <span class="stringliteral">4</span> <span class="keyword">AS</span> <span class="stringliteral">&#39;a.y&#39;</span></div>
<div class="line"><span class="keyword">FOR</span> JSON PATH</div>
</div><!-- fragment --><p>Results in: </p><div class="fragment"><div class="line">recordset = [ { &#39;JSON_F52E2B61-18A1-11d1-B105-00805F49916B&#39;: &#39;{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:1,&quot;d&quot;:2},&quot;x&quot;:3,&quot;y&quot;:4}}&#39; } ]</div>
</div><!-- fragment --><p>You can enable built-in JSON parser with <code>config.parseJSON = true</code>. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this: </p><div class="fragment"><div class="line">recordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]</div>
</div><!-- fragment --><p><b>IMPORTANT</b>: In order for this to work, there must be exactly one column named <code>JSON_F52E2B61-18A1-11d1-B105-00805F49916B</code> in the recordset.</p>
<p>More information about JSON support can be found in <a href="https://msdn.microsoft.com/en-us/library/dn921882.aspx">official documentation</a>.</p>
<h1><a class="anchor" id="autotoc_md14920"></a>
Errors</h1>
<p>There are 4 types of errors you can handle:</p>
<ul>
<li><b>ConnectionError</b> - Errors related to connections and connection pool.</li>
<li><b>TransactionError</b> - Errors related to creating, committing and rolling back transactions.</li>
<li><b>RequestError</b> - Errors related to queries and stored procedures execution.</li>
<li><b>PreparedStatementError</b> - Errors related to prepared statements.</li>
</ul>
<p>Those errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with <code>err.originalError</code>.</p>
<p>SQL Server may generate more than one error for one request so you can access preceding errors with <code>err.precedingErrors</code>.</p>
<h2><a class="anchor" id="autotoc_md14921"></a>
Error Codes</h2>
<p>Each known error has <code>name</code>, <code>code</code> and <code>message</code> properties.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name  </th><th class="markdownTableHeadLeft">Code  </th><th class="markdownTableHeadLeft">Message   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">ELOGIN  </td><td class="markdownTableBodyLeft">Login failed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">ETIMEOUT  </td><td class="markdownTableBodyLeft">Connection timeout.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">EDRIVER  </td><td class="markdownTableBodyLeft">Unknown driver.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">EALREADYCONNECTED  </td><td class="markdownTableBodyLeft">Database is already connected!   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">EALREADYCONNECTING  </td><td class="markdownTableBodyLeft">Already connecting to database!   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">ENOTOPEN  </td><td class="markdownTableBodyLeft">Connection not yet open.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">EINSTLOOKUP  </td><td class="markdownTableBodyLeft">Instance lookup failed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">ESOCKET  </td><td class="markdownTableBodyLeft">Socket error.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ConnectionError</code>  </td><td class="markdownTableBodyLeft">ECONNCLOSED  </td><td class="markdownTableBodyLeft">Connection is closed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>TransactionError</code>  </td><td class="markdownTableBodyLeft">ENOTBEGUN  </td><td class="markdownTableBodyLeft">Transaction has not begun.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>TransactionError</code>  </td><td class="markdownTableBodyLeft">EALREADYBEGUN  </td><td class="markdownTableBodyLeft">Transaction has already begun.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>TransactionError</code>  </td><td class="markdownTableBodyLeft">EREQINPROG  </td><td class="markdownTableBodyLeft">Can't commit/rollback transaction. There is a request in progress.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>TransactionError</code>  </td><td class="markdownTableBodyLeft">EABORT  </td><td class="markdownTableBodyLeft">Transaction has been aborted.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">EREQUEST  </td><td class="markdownTableBodyLeft">Message from SQL Server. Error object contains additional details.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">ECANCEL  </td><td class="markdownTableBodyLeft">Cancelled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">ETIMEOUT  </td><td class="markdownTableBodyLeft">Request timeout.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">EARGS  </td><td class="markdownTableBodyLeft">Invalid number of arguments.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">EINJECT  </td><td class="markdownTableBodyLeft">SQL injection warning.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>RequestError</code>  </td><td class="markdownTableBodyLeft">ENOCONN  </td><td class="markdownTableBodyLeft">No connection is specified for that request.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PreparedStatementError</code>  </td><td class="markdownTableBodyLeft">EARGS  </td><td class="markdownTableBodyLeft">Invalid number of arguments.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PreparedStatementError</code>  </td><td class="markdownTableBodyLeft">EINJECT  </td><td class="markdownTableBodyLeft">SQL injection warning.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PreparedStatementError</code>  </td><td class="markdownTableBodyLeft">EALREADYPREPARED  </td><td class="markdownTableBodyLeft">Statement is already prepared.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PreparedStatementError</code>  </td><td class="markdownTableBodyLeft">ENOTPREPARED  </td><td class="markdownTableBodyLeft">Statement is not prepared.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md14922"></a>
Detailed SQL Errors</h2>
<p>SQL errors (<code>RequestError</code> with <code>err.code</code> equal to <code>EREQUEST</code>) contains additional details.</p>
<ul>
<li><b>err.number</b> - The error number.</li>
<li><b>err.state</b> - The error state, used as a modifier to the number.</li>
<li><b>err.class</b> - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found <a href="https://msdn.microsoft.com/en-us/library/dd304156.aspx">here</a>.</li>
<li><b>err.lineNumber</b> - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.</li>
<li><b>err.serverName</b> - The server name.</li>
<li><b>err.procName</b> - The stored procedure name.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14923"></a>
Informational messages</h1>
<p>To receive informational messages generated by <code>PRINT</code> or <code>RAISERROR</code> commands use:</p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.on(&#39;info&#39;, info =&gt; {</div>
<div class="line">    console.dir(info)</div>
<div class="line">})</div>
<div class="line">request.query(&#39;print \&#39;Hello world.\&#39;;&#39;, (err, result) =&gt; {</div>
<div class="line">    // ...</div>
<div class="line">})</div>
</div><!-- fragment --><p>Structure of informational message:</p>
<ul>
<li><b>info.message</b> - Message.</li>
<li><b>info.number</b> - The message number.</li>
<li><b>info.state</b> - The message state, used as a modifier to the number.</li>
<li><b>info.class</b> - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found <a href="https://msdn.microsoft.com/en-us/library/dd304156.aspx">here</a>.</li>
<li><b>info.lineNumber</b> - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.</li>
<li><b>info.serverName</b> - The server name.</li>
<li><b>info.procName</b> - The stored procedure name.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14924"></a>
Metadata</h1>
<p>Recordset metadata are accessible through the <code>recordset.columns</code> property.</p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.query(&#39;select convert(decimal(18, 4), 1) as first, \&#39;asdf\&#39; as second&#39;, (err, result) =&gt; {</div>
<div class="line">    console.dir(result.recordset.columns)</div>
<div class="line"> </div>
<div class="line">    console.log(result.recordset.columns.first.type === sql.Decimal) // true</div>
<div class="line">    console.log(result.recordset.columns.second.type === sql.VarChar) // true</div>
<div class="line">})</div>
</div><!-- fragment --><p>Columns structure for example above:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    first: {</div>
<div class="line">        index: 0,</div>
<div class="line">        name: &#39;first&#39;,</div>
<div class="line">        length: 17,</div>
<div class="line">        type: [sql.Decimal],</div>
<div class="line">        scale: 4,</div>
<div class="line">        precision: 18,</div>
<div class="line">        nullable: true,</div>
<div class="line">        caseSensitive: false</div>
<div class="line">        identity: false</div>
<div class="line">        readOnly: true</div>
<div class="line">    },</div>
<div class="line">    second: {</div>
<div class="line">        index: 1,</div>
<div class="line">        name: &#39;second&#39;,</div>
<div class="line">        length: 4,</div>
<div class="line">        type: [sql.VarChar],</div>
<div class="line">        nullable: false,</div>
<div class="line">        caseSensitive: false</div>
<div class="line">        identity: false</div>
<div class="line">        readOnly: true</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14925"></a>
Data Types</h1>
<p>You can define data types with length/precision/scale:</p>
<div class="fragment"><div class="line">request.input(&quot;name&quot;, sql.VarChar, &quot;abc&quot;)               // varchar(3)</div>
<div class="line">request.input(&quot;name&quot;, sql.VarChar(50), &quot;abc&quot;)           // varchar(50)</div>
<div class="line">request.input(&quot;name&quot;, sql.VarChar(sql.MAX), &quot;abc&quot;)      // varchar(MAX)</div>
<div class="line">request.output(&quot;name&quot;, sql.VarChar)                     // varchar(8000)</div>
<div class="line">request.output(&quot;name&quot;, sql.VarChar, &quot;abc&quot;)              // varchar(3)</div>
<div class="line"> </div>
<div class="line">request.input(&quot;name&quot;, sql.Decimal, 155.33)              // decimal(18, 0)</div>
<div class="line">request.input(&quot;name&quot;, sql.Decimal(10), 155.33)          // decimal(10, 0)</div>
<div class="line">request.input(&quot;name&quot;, sql.Decimal(10, 2), 155.33)       // decimal(10, 2)</div>
<div class="line"> </div>
<div class="line">request.input(&quot;name&quot;, sql.DateTime2, new Date())        // datetime2(7)</div>
<div class="line">request.input(&quot;name&quot;, sql.DateTime2(5), new Date())     // datetime2(5)</div>
</div><!-- fragment --><p>List of supported data types:</p>
<div class="fragment"><div class="line">sql.Bit</div>
<div class="line">sql.BigInt</div>
<div class="line">sql.Decimal ([precision], [scale])</div>
<div class="line">sql.Float</div>
<div class="line">sql.Int</div>
<div class="line">sql.Money</div>
<div class="line">sql.Numeric ([precision], [scale])</div>
<div class="line">sql.SmallInt</div>
<div class="line">sql.SmallMoney</div>
<div class="line">sql.Real</div>
<div class="line">sql.TinyInt</div>
<div class="line"> </div>
<div class="line">sql.Char ([length])</div>
<div class="line">sql.NChar ([length])</div>
<div class="line">sql.Text</div>
<div class="line">sql.NText</div>
<div class="line">sql.VarChar ([length])</div>
<div class="line">sql.NVarChar ([length])</div>
<div class="line">sql.Xml</div>
<div class="line"> </div>
<div class="line">sql.Time ([scale])</div>
<div class="line">sql.Date</div>
<div class="line">sql.DateTime</div>
<div class="line">sql.DateTime2 ([scale])</div>
<div class="line">sql.DateTimeOffset ([scale])</div>
<div class="line">sql.SmallDateTime</div>
<div class="line"> </div>
<div class="line">sql.UniqueIdentifier</div>
<div class="line"> </div>
<div class="line">sql.Variant</div>
<div class="line"> </div>
<div class="line">sql.Binary</div>
<div class="line">sql.VarBinary ([length])</div>
<div class="line">sql.Image</div>
<div class="line"> </div>
<div class="line">sql.UDT</div>
<div class="line">sql.Geography</div>
<div class="line">sql.Geometry</div>
</div><!-- fragment --><p>To setup MAX length for <code>VarChar</code>, <code>NVarChar</code> and <code>VarBinary</code> use <code>sql.MAX</code> length. Types <code>sql.XML</code> and <code>sql.Variant</code> are not supported as input parameters.</p>
<h1><a class="anchor" id="autotoc_md14926"></a>
SQL injection</h1>
<p>This module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.</p>
<div class="fragment"><div class="line">const request = new sql.Request()</div>
<div class="line">request.input(&#39;myval&#39;, sql.VarChar, &#39;-- commented&#39;)</div>
<div class="line">request.query(&#39;select @myval as myval&#39;, (err, result) =&gt; {</div>
<div class="line">    console.dir(result)</div>
<div class="line">})</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14927"></a>
Known issues</h1>
<h2><a class="anchor" id="autotoc_md14928"></a>
Tedious</h2>
<ul>
<li>If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with &lsquo;config.options.tdsVersion = '7_1&rsquo;` (<a href="https://github.com/tediousjs/node-mssql/issues/36">issue</a>)</li>
<li>If you're executing a statement longer than 4000 chars on SQL Server 2000, always use <a href="#batch-batch-callback">batch</a> instead of <a href="#query-command-callback">query</a> (<a href="https://github.com/tediousjs/node-mssql/issues/68">issue</a>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md14929"></a>
msnodesqlv8</h2>
<ul>
<li>msnodesqlv8 has problem with errors during transactions - <a href="https://github.com/tediousjs/node-mssql/issues/77">reported</a>.</li>
<li>msnodesqlv8 doesn't support <a href="#detailed-sql-errors">detailed SQL errors</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14930"></a>
5.x to 6.x changes</h1>
<ul>
<li>Upgraded <code>tarn.js</code> so <code>_poolDestroy</code> can take advantage of being a promise</li>
<li><code>ConnectionPool.close()</code> now returns a promise / callbacks will be executed once closing of the pool is complete; you must make sure that connections are properly released back to the pool otherwise the pool may fail to close.</li>
<li>It is safe to pass read-only config objects to the library; config objects are now cloned</li>
<li><code>options.encrypt</code> is now <code>true</code> by default</li>
<li><code>TYPES.Null</code> has now been removed</li>
<li>Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]</li>
<li>You can now close the global connection by reference and this will clean up the global connection, eg: <code>const conn = sql.connect(); conn.close()</code> will be the same as <code>sql.close()</code></li>
<li>Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date</li>
<li>Repeat calls to the global connect function (<code>sql.connect()</code>) will return the current global connection if it exists (rather than throwing an error)</li>
<li>Attempting to add a parameter to queries / stored procedures will now throw an error; use <code>replaceInput</code> and <code>replaceOutput</code> instead</li>
<li>Invalid isolation levels passed to <code>Transaction</code>s will now throw an error</li>
<li><code>ConnectionPool</code> now reports if it is healthy or not (<code>ConnectionPool.healthy</code>) which can be used to determine if the pool is able to create new connections or not</li>
<li>Pause/Resume support for streamed results has been added to the msnodesqlv8 driver</li>
</ul>
<h1><a class="anchor" id="autotoc_md14931"></a>
4.x to 5.x changes</h1>
<ul>
<li>Moved pool library from <code>node-pool</code> to <code>tarn.js</code></li>
<li><code>ConnectionPool.pool.size</code> deprecated, use <code>ConnectionPool.size</code> instead</li>
<li><code>ConnectionPool.pool.available</code> deprecated, use <code>ConnectionPool.available</code> instead</li>
<li><code>ConnectionPool.pool.pending</code> deprecated, use <code>ConnectionPool.pending</code> instead</li>
<li><code>ConnectionPool.pool.borrowed</code> deprecated, use <code>ConnectionPool.borrowed</code> instead</li>
</ul>
<h1><a class="anchor" id="autotoc_md14932"></a>
3.x to 4.x changes</h1>
<ul>
<li>Library &amp; tests are rewritten to ES6.</li>
<li><code>Connection</code> was renamed to <code>ConnectionPool</code>.</li>
<li>Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use <code>msnodesqlv8</code> driver, use &lsquo;const sql = require('mssql/msnodesqlv8&rsquo;)<code>syntax.</code></li>
<li><code>Every callback/resolve now returns</code>result<code>object only. This object contains</code>recordsets&lt;tt&gt;(array of recordsets),recordset&lt;tt&gt;(first recordset from array of recordsets),rowsAffected<code>(array of numbers representig number of affected rows by each insert/update/delete statement) and</code>output&lsquo; (key/value collection of output parameters&rsquo; values).</li>
<li>Affected rows are now returned as an array. A separate number for each SQL statement.</li>
<li>Directive <code>multiple: true</code> was removed.</li>
<li><code>Transaction</code> and <code>PreparedStatement</code> internal queues was removed.</li>
<li>ConnectionPool no longer emits <code>connect</code> and <code>close</code> events.</li>
<li>Removed verbose and debug mode.</li>
<li>Removed support for <code>tds</code> and <code>msnodesql</code> drivers.</li>
<li>Removed support for Node versions lower than 4. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19 </li>
  </ul>
</div>
</body>
</html>
